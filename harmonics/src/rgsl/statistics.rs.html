<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-6.0.0/src/statistics.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>statistics.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../rgsl/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../rgsl/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../rgsl/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
</pre><pre class="rust"><code><span class="comment">//</span>
<span class="comment">// A rust binding for the GSL library by Guillaume Gomez (guillaume1.gomez@gmail.com)</span>
<span class="comment">//</span>

<span class="doccomment">/*!
# Statistics

This chapter describes the statistical functions in the library. The basic statistical functions include routines to compute the mean,
variance and standard deviation. More advanced functions allow you to calculate absolute deviations, skewness, and kurtosis as well as the
median and arbitrary percentiles. The algorithms use recurrence relations to compute average quantities in a stable way, without large
intermediate values that might overflow.

## Weighted Samples

The functions described in this section allow the computation of statistics for weighted samples. The functions accept an array of
samples, x_i, with associated weights, w_i. Each sample x_i is considered as having been drawn from a Gaussian distribution with variance
\sigma_i^2. The sample weight w_i is defined as the reciprocal of this variance, w_i = 1/\sigma_i^2. Setting a weight to zero corresponds
to removing a sample from a dataset.

## Maximum and Minimum values

The following functions find the maximum and minimum values of a dataset (or their indices). If the data contains NaNs then a NaN will be
returned, since the maximum or minimum value is undefined. For functions which return an index, the location of the first NaN in the array is returned.

## Median and Percentiles

The median and percentile functions described in this section operate on sorted data. For convenience we use quantiles, measured on a
scale of 0 to 1, instead of percentiles (which use a scale of 0 to 100).

## References and Further Reading

The standard reference for almost any topic in statistics is the multi-volume Advanced Theory of Statistics by Kendall and Stuart.

Maurice Kendall, Alan Stuart, and J. Keith Ord. The Advanced Theory of Statistics (multiple volumes) reprinted as Kendall’s Advanced
Theory of Statistics. Wiley, ISBN 047023380X.
Many statistical concepts can be more easily understood by a Bayesian approach. The following book by Gelman, Carlin, Stern and Rubin
gives a comprehensive coverage of the subject.

Andrew Gelman, John B. Carlin, Hal S. Stern, Donald B. Rubin. Bayesian Data Analysis. Chapman &amp; Hall, ISBN 0412039915.
For physicists the Particle Data Group provides useful reviews of Probability and Statistics in the “Mathematical Tools” section of its
Annual Review of Particle Physics.

Review of Particle Properties R.M. Barnett et al., Physical Review D54, 1 (1996)
The Review of Particle Physics is available online at the website http://pdg.lbl.gov/.
!*/</span>

<span class="doccomment">/// This function returns the arithmetic mean of data, a dataset of length n with stride stride. The</span>
<span class="doccomment">/// arithmetic mean, or sample mean, is denoted by \Hat\mu and defined as,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// \Hat\mu = (1/N) \sum x_i</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where x_i are the elements of the dataset data. For samples drawn from a gaussian distribution</span>
<span class="doccomment">/// the variance of \Hat\mu is \sigma^2 / N.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_mean&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mean</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_mean</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the estimated, or sample, variance of data, a dataset of length n with</span>
<span class="doccomment">/// stride stride. The estimated variance is denoted by \Hat\sigma^2 and is defined by,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// \Hat\sigma^2 = (1/(N-1)) \sum (x_i - \Hat\mu)^2</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where x_i are the elements of the dataset data. Note that the normalization factor of 1/(N-1)</span>
<span class="doccomment">/// results from the derivation of \Hat\sigma^2 as an unbiased estimator of the population variance</span>
<span class="doccomment">/// \sigma^2. For samples drawn from a Gaussian distribution the variance of \Hat\sigma^2 itself is</span>
<span class="doccomment">/// 2 \sigma^4 / N.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function computes the mean via a call to gsl_stats_mean. If you have already computed the</span>
<span class="doccomment">/// mean then you can pass it directly to gsl_stats_variance_m.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_variance&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">variance</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_variance</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the sample variance of data relative to the given value of mean. The</span>
<span class="doccomment">/// function is computed with \Hat\mu replaced by the value of mean that you supply,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// \Hat\sigma^2 = (1/(N-1)) \sum (x_i - mean)^2</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_variance_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">variance_m</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_variance_m</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>) }
}

<span class="doccomment">/// The standard deviation is defined as the square root of the variance. This function returns the</span>
<span class="doccomment">/// square root of the corresponding variance functions above.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_sd&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sd</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_sd</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// The standard deviation is defined as the square root of the variance. This function returns the</span>
<span class="doccomment">/// square root of the corresponding variance functions above.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_sd_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sd_m</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_sd_m</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>) }
}

<span class="doccomment">/// This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m</span>
<span class="doccomment">/// the user-supplied value of mean is used, and for gsl_stats_tss it is computed using</span>
<span class="doccomment">/// gsl_stats_mean.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// TSS =  \sum (x_i - mean)^2</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_tss&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">tss</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_tss</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m</span>
<span class="doccomment">/// the user-supplied value of mean is used, and for gsl_stats_tss it is computed using</span>
<span class="doccomment">/// gsl_stats_mean.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// TSS =  \sum (x_i - mean)^2</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_tss_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">tss_m</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_tss_m</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>) }
}

<span class="doccomment">/// This function computes an unbiased estimate of the variance of data when the population mean</span>
<span class="doccomment">/// mean of the underlying distribution is known a priori. In this case the estimator for the</span>
<span class="doccomment">/// variance uses the factor 1/N and the sample mean \Hat\mu is replaced by the known population</span>
<span class="doccomment">/// mean \mu,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// \Hat\sigma^2 = (1/N) \sum (x_i - \mu)^2</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_variance_with_fixed_mean&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">variance_with_fixed_mean</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_variance_with_fixed_mean</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>) }
}

<span class="doccomment">/// This function calculates the standard deviation of data for a fixed population mean mean. The</span>
<span class="doccomment">/// result is the square root of the corresponding variance function.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_sd_with_fixed_mean&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sd_with_fixed_mean</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_sd_with_fixed_mean</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>) }
}

<span class="doccomment">/// This function computes the absolute deviation from the mean of data, a dataset of length n with</span>
<span class="doccomment">/// stride stride. The absolute deviation from the mean is defined as,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// absdev  = (1/N) \sum |x_i - \Hat\mu|</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where x_i are the elements of the dataset data. The absolute deviation from the mean provides a</span>
<span class="doccomment">/// more robust measure of the width of a distribution than the variance. This function computes the</span>
<span class="doccomment">/// mean of data via a call to gsl_stats_mean.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_absdev&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">absdev</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_absdev</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the absolute deviation of the dataset data relative to the given value of</span>
<span class="doccomment">/// mean,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// absdev  = (1/N) \sum |x_i - mean|</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function is useful if you have already computed the mean of data (and want to avoid</span>
<span class="doccomment">/// recomputing it), or wish to calculate the absolute deviation relative to another value (such as</span>
<span class="doccomment">/// zero, or the median).</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_absdev_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">absdev_m</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_absdev_m</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>) }
}

<span class="doccomment">/// This function computes the skewness of data, a dataset of length n with stride stride. The</span>
<span class="doccomment">/// skewness is defined as,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// skew = (1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^3</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where x_i are the elements of the dataset data. The skewness measures the asymmetry of the tails</span>
<span class="doccomment">/// of a distribution.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The function computes the mean and estimated standard deviation of data via calls to [`mean`]</span>
<span class="doccomment">/// and [`sd`].</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_skew&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">skew</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_skew</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the skewness of the dataset data using the given values of the mean mean</span>
<span class="doccomment">/// and standard deviation sd,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// skew = (1/N) \sum ((x_i - mean)/sd)^3</span>
<span class="doccomment">///</span>
<span class="doccomment">/// These functions are useful if you have already computed the mean and standard deviation of data</span>
<span class="doccomment">/// and want to avoid recomputing them.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_skew_m_sd&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">skew_m_sd</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>, <span class="ident">sd</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_skew_m_sd</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>, <span class="ident">sd</span>) }
}

<span class="doccomment">/// This function computes the kurtosis of data, a dataset of length n with stride stride. The</span>
<span class="doccomment">/// kurtosis is defined as,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// kurtosis = ((1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^4)  - 3</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The kurtosis measures how sharply peaked a distribution is, relative to its width. The kurtosis</span>
<span class="doccomment">/// is normalized to zero for a Gaussian distribution.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_kurtosis&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">kurtosis</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_kurtosis</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the kurtosis of the dataset data using the given values of the mean mean</span>
<span class="doccomment">/// and standard deviation sd,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// kurtosis = ((1/N) \sum ((x_i - mean)/sd)^4) - 3</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function is useful if you have already computed the mean and standard deviation of data and</span>
<span class="doccomment">/// want to avoid recomputing them.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_kurtosis_m_sd&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">kurtosis_m_sd</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>, <span class="ident">sd</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_kurtosis_m_sd</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>, <span class="ident">sd</span>) }
}

<span class="doccomment">/// This function computes the lag-1 autocorrelation of the dataset data.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// a_1 = {\sum_{i = 1}^{n} (x_{i} - \Hat\mu) (x_{i-1} - \Hat\mu)</span>
<span class="doccomment">///        \over</span>
<span class="doccomment">///        \sum_{i = 1}^{n} (x_{i} - \Hat\mu) (x_{i} - \Hat\mu)}</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_lag1_autocorrelation&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">lag1_autocorrelation</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_lag1_autocorrelation</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the lag-1 autocorrelation of the dataset data using the given value of</span>
<span class="doccomment">/// the mean mean.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_lag1_autocorrelation_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">lag1_autocorrelation_m</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">mean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_lag1_autocorrelation_m</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>) }
}

<span class="doccomment">/// This function computes the covariance of the datasets data1 and data2 which must both be of the</span>
<span class="doccomment">/// same length n.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// covar = (1/(n - 1)) \sum_{i = 1}^{n} (x_i - \Hat x) (y_i - \Hat y)</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_covariance&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">covariance</span>(<span class="ident">data1</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride1</span>: <span class="ident">usize</span>, <span class="ident">data2</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride2</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_covariance</span>(<span class="ident">data1</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride1</span>, <span class="ident">data2</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride2</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the covariance of the datasets data1 and data2 using the given values of</span>
<span class="doccomment">/// the means, mean1 and mean2. This is useful if you have already computed the means of data1 and</span>
<span class="doccomment">/// data2 and want to avoid recomputing them.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_covariance_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">covariance_m</span>(
    <span class="ident">data1</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride1</span>: <span class="ident">usize</span>,
    <span class="ident">data2</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride2</span>: <span class="ident">usize</span>,
    <span class="ident">n</span>: <span class="ident">usize</span>,
    <span class="ident">mean1</span>: <span class="ident">f64</span>,
    <span class="ident">mean2</span>: <span class="ident">f64</span>,
) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> {
        <span class="ident">sys::gsl_stats_covariance_m</span>(
            <span class="ident">data1</span>.<span class="ident">as_ptr</span>(),
            <span class="ident">stride1</span>,
            <span class="ident">data2</span>.<span class="ident">as_ptr</span>(),
            <span class="ident">stride2</span>,
            <span class="ident">n</span>,
            <span class="ident">mean1</span>,
            <span class="ident">mean2</span>,
        )
    }
}

<span class="doccomment">/// This function efficiently computes the Pearson correlation coefficient between the datasets</span>
<span class="doccomment">/// data1 and data2 which must both be of the same length n.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// r = cov(x, y) / (\Hat\sigma_x \Hat\sigma_y)</span>
<span class="doccomment">///   = {1/(n-1) \sum (x_i - \Hat x) (y_i - \Hat y)</span>
<span class="doccomment">///      \over</span>
<span class="doccomment">///      \sqrt{1/(n-1) \sum (x_i - \Hat x)^2} \sqrt{1/(n-1) \sum (y_i - \Hat y)^2}</span>
<span class="doccomment">///     }</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_correlation&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">correlation</span>(<span class="ident">data1</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride1</span>: <span class="ident">usize</span>, <span class="ident">data2</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride2</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_correlation</span>(<span class="ident">data1</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride1</span>, <span class="ident">data2</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride2</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the Spearman rank correlation coefficient between the datasets data1 and</span>
<span class="doccomment">/// data2 which must both be of the same length n. Additional workspace of size 2*n is required in</span>
<span class="doccomment">/// work. The Spearman rank correlation between vectors x and y is equivalent to the Pearson</span>
<span class="doccomment">/// correlation between the ranked vectors x_R and y_R, where ranks are defined to be the average of</span>
<span class="doccomment">/// the positions of an element in the ascending order of the values.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_spearman&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">spearman</span>(
    <span class="ident">data1</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride1</span>: <span class="ident">usize</span>,
    <span class="ident">data2</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride2</span>: <span class="ident">usize</span>,
    <span class="ident">n</span>: <span class="ident">usize</span>,
    <span class="ident">work</span>: <span class="kw-2">&amp;mut</span> [<span class="ident">f64</span>],
) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> {
        <span class="ident">sys::gsl_stats_spearman</span>(
            <span class="ident">data1</span>.<span class="ident">as_ptr</span>(),
            <span class="ident">stride1</span>,
            <span class="ident">data2</span>.<span class="ident">as_ptr</span>(),
            <span class="ident">stride2</span>,
            <span class="ident">n</span>,
            <span class="ident">work</span>.<span class="ident">as_mut_ptr</span>(),
        )
    }
}

<span class="doccomment">/// This function returns the weighted mean of the dataset data with stride stride and length n,</span>
<span class="doccomment">/// using the set of weights w with stride wstride and length n. The weighted mean is defined as,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// \Hat\mu = (\sum w_i x_i) / (\sum w_i)</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wmean&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wmean</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wmean</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the estimated variance of the dataset data with stride stride and length</span>
<span class="doccomment">/// n, using the set of weights w with</span>
<span class="doccomment">/// stride wstride and length n. The estimated variance of a weighted dataset is calculated as,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// \Hat\sigma^2 = ((\sum w_i)/((\sum w_i)^2 - \sum (w_i^2)))</span>
<span class="doccomment">///                 \sum w_i (x_i - \Hat\mu)^2</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Note that this expression reduces to an unweighted variance with the familiar 1/(N-1) factor</span>
<span class="doccomment">/// when there are N equal non-zero weights.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wvariance&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wvariance</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wvariance</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the estimated variance of the weighted dataset data using the given</span>
<span class="doccomment">/// weighted mean wmean.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wvariance_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wvariance_m</span>(
    <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">wstride</span>: <span class="ident">usize</span>,
    <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride</span>: <span class="ident">usize</span>,
    <span class="ident">n</span>: <span class="ident">usize</span>,
    <span class="ident">wmean</span>: <span class="ident">f64</span>,
) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wvariance_m</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">wmean</span>) }
}

<span class="doccomment">/// The standard deviation is defined as the square root of the variance. This function returns the</span>
<span class="doccomment">/// square root of the corresponding variance function [`wvariance`] above.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wsd&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wsd</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wsd</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the square root of the corresponding variance function</span>
<span class="doccomment">/// [`wvariance_m`] above.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wsd_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wsd_m</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">wmean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wsd_m</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">wmean</span>) }
}

<span class="doccomment">/// This function computes an unbiased estimate of the variance of the weighted dataset data when</span>
<span class="doccomment">/// the population mean mean of the underlying distribution is known a priori. In this case the</span>
<span class="doccomment">/// estimator for the variance replaces the sample mean \Hat\mu by the known population mean \mu,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// \Hat\sigma^2 = (\sum w_i (x_i - \mu)^2) / (\sum w_i)</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wvariance_with_fixed_mean&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wvariance_with_fixed_mean</span>(
    <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">wstride</span>: <span class="ident">usize</span>,
    <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride</span>: <span class="ident">usize</span>,
    <span class="ident">n</span>: <span class="ident">usize</span>,
    <span class="ident">mean</span>: <span class="ident">f64</span>,
) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> {
        <span class="ident">sys::gsl_stats_wvariance_with_fixed_mean</span>(
            <span class="ident">w</span>.<span class="ident">as_ptr</span>(),
            <span class="ident">wstride</span>,
            <span class="ident">data</span>.<span class="ident">as_ptr</span>(),
            <span class="ident">stride</span>,
            <span class="ident">n</span>,
            <span class="ident">mean</span>,
        )
    }
}

<span class="doccomment">/// The standard deviation is defined as the square root of the variance. This function returns the</span>
<span class="doccomment">/// square root of the corresponding variance function above.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wsd_with_fixed_mean&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wsd_with_fixed_mean</span>(
    <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">wstride</span>: <span class="ident">usize</span>,
    <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride</span>: <span class="ident">usize</span>,
    <span class="ident">n</span>: <span class="ident">usize</span>,
    <span class="ident">mean</span>: <span class="ident">f64</span>,
) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> {
        <span class="ident">sys::gsl_stats_wsd_with_fixed_mean</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">mean</span>)
    }
}

<span class="doccomment">/// This function returns the weighted total sum of squares (TSS) of data about the weighted mean.</span>
<span class="doccomment">/// For gsl_stats_wtss_m the user-supplied value of wmean is used, and for gsl_stats_wtss it is</span>
<span class="doccomment">/// computed using gsl_stats_wmean.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// TSS =  \sum w_i (x_i - wmean)^2</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wtss&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wtss</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wtss</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the weighted total sum of squares (TSS) of data about the weighted mean.</span>
<span class="doccomment">/// For gsl_stats_wtss_m the user-supplied value of wmean is used, and for gsl_stats_wtss it is</span>
<span class="doccomment">/// computed using gsl_stats_wmean.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// TSS =  \sum w_i (x_i - wmean)^2</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wtss_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wtss_m</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">wmean</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wtss_m</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">wmean</span>) }
}

<span class="doccomment">/// This function computes the weighted absolute deviation from the weighted mean of data. The absolute deviation from the mean is defined</span>
<span class="doccomment">/// as,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// absdev = (\sum w_i |x_i - \Hat\mu|) / (\sum w_i)</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wabsdev&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wabsdev</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wabsdev</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the absolute deviation of the weighted dataset data about the given weighted mean wmean.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wabsdev_m&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wabsdev_m</span>(
    <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">wstride</span>: <span class="ident">usize</span>,
    <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride</span>: <span class="ident">usize</span>,
    <span class="ident">n</span>: <span class="ident">usize</span>,
    <span class="ident">wmean</span>: <span class="ident">f64</span>,
) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wabsdev_m</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">wmean</span>) }
}

<span class="doccomment">/// This function computes the weighted skewness of the dataset data.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// skew = (\sum w_i ((x_i - \Hat x)/\Hat \sigma)^3) / (\sum w_i)</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wskew&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wskew</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wskew</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the weighted skewness of the dataset data using the given values of the</span>
<span class="doccomment">/// weighted mean and weighted standard deviation, wmean and wsd.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wskew_m_sd&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wskew_m_sd</span>(
    <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">wstride</span>: <span class="ident">usize</span>,
    <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride</span>: <span class="ident">usize</span>,
    <span class="ident">n</span>: <span class="ident">usize</span>,
    <span class="ident">wmean</span>: <span class="ident">f64</span>,
    <span class="ident">wsd</span>: <span class="ident">f64</span>,
) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wskew_m_sd</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">wmean</span>, <span class="ident">wsd</span>) }
}

<span class="doccomment">/// This function computes the weighted kurtosis of the dataset data.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// kurtosis = ((\sum w_i ((x_i - \Hat x)/\Hat \sigma)^4) / (\sum w_i)) - 3</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wkurtosis&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wkurtosis</span>(<span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">wstride</span>: <span class="ident">usize</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_wkurtosis</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function computes the weighted kurtosis of the dataset data using the given values of the</span>
<span class="doccomment">/// weighted mean and weighted standard deviation, wmean and wsd.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_wkurtosis_m_sd&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wkurtosis_m_sd</span>(
    <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">wstride</span>: <span class="ident">usize</span>,
    <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>],
    <span class="ident">stride</span>: <span class="ident">usize</span>,
    <span class="ident">n</span>: <span class="ident">usize</span>,
    <span class="ident">wmean</span>: <span class="ident">f64</span>,
    <span class="ident">wsd</span>: <span class="ident">f64</span>,
) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> {
        <span class="ident">sys::gsl_stats_wkurtosis_m_sd</span>(<span class="ident">w</span>.<span class="ident">as_ptr</span>(), <span class="ident">wstride</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">wmean</span>, <span class="ident">wsd</span>)
    }
}

<span class="doccomment">/// This function returns the maximum value in data, a dataset of length n with stride stride. The</span>
<span class="doccomment">/// maximum value is defined as the value of the element x_i which satisfies x_i &gt;= x_j for all j.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// If you want instead to find the element with the largest absolute magnitude you will need to</span>
<span class="doccomment">/// apply fabs or abs to your data before calling this function.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_max&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">max</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_max</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the minimum value in data, a dataset of length n with stride stride. The</span>
<span class="doccomment">/// minimum value is defined as the value of the element x_i which satisfies x_i &lt;= x_j for all j.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// If you want instead to find the element with the smallest absolute magnitude you will need to</span>
<span class="doccomment">/// apply fabs or abs to your data before calling this function.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_min&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">min</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_min</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function finds both the minimum and maximum values min, max in data in a single pass.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Returns `(min, max)`.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_minmax&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">minmax</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; (<span class="ident">f64</span>, <span class="ident">f64</span>) {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">min</span> <span class="op">=</span> <span class="number">0.</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">max</span> <span class="op">=</span> <span class="number">0.</span>;
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_minmax</span>(<span class="kw-2">&amp;mut</span> <span class="ident">min</span>, <span class="kw-2">&amp;mut</span> <span class="ident">max</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) };
    (<span class="ident">min</span>, <span class="ident">max</span>)
}

<span class="doccomment">/// This function returns the index of the maximum value in data, a dataset of length n with stride</span>
<span class="doccomment">/// stride. The maximum value is defined as the value of the element x_i which satisfies x_i &gt;= x_j</span>
<span class="doccomment">/// for all j. When there are several equal maximum elements then the first one is chosen.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_max_index&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">max_index</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">usize</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_max_index</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the index of the minimum value in data, a dataset of length n with stride</span>
<span class="doccomment">/// stride. The minimum value is defined as the value of the element x_i which satisfies x_i &gt;= x_j</span>
<span class="doccomment">/// for all j. When there are several equal minimum elements then the first one is chosen.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_min_index&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">min_index</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">usize</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_min_index</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns the indexes min_index, max_index of the minimum and maximum values in data</span>
<span class="doccomment">/// in a single pass.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Returns `(min_index, max_index)`.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_minmax_index&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">minmax_index</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; (<span class="ident">usize</span>, <span class="ident">usize</span>) {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">min_index</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">max_index</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">unsafe</span> {
        <span class="ident">sys::gsl_stats_minmax_index</span>(<span class="kw-2">&amp;mut</span> <span class="ident">min_index</span>, <span class="kw-2">&amp;mut</span> <span class="ident">max_index</span>, <span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>)
    };
    (<span class="ident">min_index</span>, <span class="ident">max_index</span>)
}

<span class="doccomment">/// This function returns the median value of sorted_data, a dataset of length n with stride stride.</span>
<span class="doccomment">/// The elements of the array must be in ascending numerical order. There are no checks to see</span>
<span class="doccomment">/// whether the data are sorted, so the function gsl_sort should always be used first.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// When the dataset has an odd number of elements the median is the value of element (n-1)/2. When</span>
<span class="doccomment">/// the dataset has an even number of elements the median is the mean of the two nearest middle</span>
<span class="doccomment">/// values, elements (n-1)/2 and n/2. Since the algorithm for computing the median involves</span>
<span class="doccomment">/// interpolation this function always returns a floating-point number, even for integer data types.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_median_from_sorted_data&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">median_from_sorted_data</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_median_from_sorted_data</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) }
}

<span class="doccomment">/// This function returns a quantile value of sorted_data, a double-precision array of length n with</span>
<span class="doccomment">/// stride stride. The elements of the array must be in ascending numerical order. The quantile is</span>
<span class="doccomment">/// determined by the f, a fraction between 0 and 1. For example, to compute the value of the 75th</span>
<span class="doccomment">/// percentile f should have the value 0.75.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// There are no checks to see whether the data are sorted, so the function gsl_sort should always</span>
<span class="doccomment">/// be used first.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The quantile is found by interpolation, using the formula</span>
<span class="doccomment">///</span>
<span class="doccomment">/// quantile = (1 - \delta) x_i + \delta x_{i+1}</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where i is floor((n - 1)f) and \delta is (n-1)f - i.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Thus the minimum value of the array (data[0*stride]) is given by f equal to zero, the maximum</span>
<span class="doccomment">/// value (data[(n-1)*stride]) is given by f equal to one and the median value is given by f equal</span>
<span class="doccomment">/// to 0.5. Since the algorithm for computing quantiles involves interpolation this function always</span>
<span class="doccomment">/// returns a floating-point number, even for integer data types.</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_stats_quantile_from_sorted_data&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">quantile_from_sorted_data</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">f</span>: <span class="ident">f64</span>) -&gt; <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">sys::gsl_stats_quantile_from_sorted_data</span>(<span class="ident">data</span>.<span class="ident">as_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">f</span>) }
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="rgsl" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>