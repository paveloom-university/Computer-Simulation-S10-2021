<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-6.0.0/src/types/multiroot.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>multiroot.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../rgsl/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../rgsl/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../rgsl/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
</pre><pre class="rust"><code><span class="comment">//</span>
<span class="comment">// A rust binding for the GSL library by Guillaume Gomez (guillaume1.gomez@gmail.com)</span>
<span class="comment">//</span>

<span class="doccomment">/*!
# Multi dimensional Root-Finding

This chapter describes functions for multidimensional root-finding (solving nonlinear systems with
n equations in n unknowns). The library provides low level components for a variety of iterative
solvers and convergence tests. These can be combined by the user to achieve the desired solution,
with full access to the intermediate steps of the iteration. Each class of methods uses the same
framework, so that you can switch between solvers at runtime without needing to recompile your
program. Each instance of a solver keeps track of its own state, allowing the solvers to be used
in multi-threaded programs. The solvers are based on the original Fortran library MINPACK.
The header file `gsl_multiroots.h` contains prototypes for the multidimensional root finding functions
and related declarations.

## Overview
The problem of multidimensional root finding requires the simultaneous solution of n equations,
f_i, in n variables, x_i,

```text
f_i (x_1, \dots, x_n) = 0 \qquad\hbox{for}~i = 1 \dots n.
```

In general there are no bracketing methods available for n dimensional systems, and no way of
knowing whether any solutions exist. All algorithms proceed from an initial guess using a
variant of the Newton iteration,

```text
x \to x&#39; = x - J^{-1} f(x)
```
where x, f are vector quantities and J is the Jacobian matrix J_{ij} = \partial f_i / \partial x_j.
Additional strategies can be used to enlarge the region of convergence. These include requiring a
decrease in the norm |f| on each step proposed by Newton’s method, or taking steepest-descent
steps in the direction of the negative gradient of |f|.

Several root-finding algorithms are available within a single framework. The user provides a
high-level driver for the algorithms, and the library provides the individual functions necessary
for each of the steps. There are three main phases of the iteration. The steps are,

- initialize solver state, `s`, for algorithm `T`
- update `s` using the iteration `T`
- test `s` for convergence, and repeat iteration if necessary

The evaluation of the Jacobian matrix can be problematic, either because programming the derivatives
is intractable or because computation of the n^2 terms of the matrix becomes too expensive.
For these reasons the algorithms provided by the library are divided into two classes according to
whether the derivatives are available or not.

The state for solvers with an analytic Jacobian matrix is held in a `gsl_multiroot_fdfsolver` struct.
The updating procedure requires both the function and its derivatives to be supplied by the user.

The state for solvers which do not use an analytic Jacobian matrix is held in a
`gsl_multiroot_fsolver` struct. The updating procedure uses only function evaluations (not derivatives).
The algorithms estimate the matrix J or J^{-1} by approximate methods.
!*/</span>

<span class="kw">use</span> <span class="ident">ffi::FFI</span>;
<span class="kw">use</span> <span class="ident">sys</span>;
<span class="kw">use</span> <span class="ident">sys::libc</span>::{<span class="ident">c_int</span>, <span class="ident">c_void</span>};

<span class="macro">ffi_wrapper!</span>(
    <span class="ident">MultiRootFSolverType</span>,
    <span class="kw-2">*const</span> <span class="ident">sys::gsl_multiroot_fsolver_type</span>,
    <span class="string">&quot;The multiroot algorithms described in this section do not require any derivative information to be
    supplied by the user. Any derivatives needed are approximated by finite differences.
    Note that if the finite-differencing step size chosen by these routines is inappropriate,
    an explicit user-supplied numerical derivative can always be used with
    derivative-based algorithms.&quot;</span>
);

<span class="kw">impl</span> <span class="ident">MultiRootFSolverType</span> {
    <span class="doccomment">///This is a version of the Hybrid algorithm which replaces calls to the Jacobian function by</span>
    <span class="doccomment">/// its finite difference approximation. The finite difference approximation is computed</span>
    <span class="doccomment">/// using `gsl_multiroots_fdjac()` with a relative step size of `GSL_SQRT_DBL_EPSILON`.</span>
    <span class="doccomment">/// Note that this step size will not be suitable for all problems.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_hybrids&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hybrids</span>() -&gt; <span class="ident">MultiRootFSolverType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_multiroot_fsolver_hybrids</span>)
    }

    <span class="doccomment">///This is a finite difference version of the Hybrid algorithm without internal scaling.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_hybrid&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hybrid</span>() -&gt; <span class="ident">MultiRootFSolverType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_multiroot_fsolver_hybrid</span>)
    }

    <span class="doccomment">/// The discrete Newton algorithm is the simplest method of solving a multidimensional</span>
    <span class="doccomment">/// system. It uses the Newton iteration</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///```text</span>
    <span class="doccomment">///x \to x - J^{-1} f(x)</span>
    <span class="doccomment">///```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// where the Jacobian matrix J is approximated by taking finite differences of the function f.</span>
    <span class="doccomment">/// The approximation scheme used by this implementation is,</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///```text</span>
    <span class="doccomment">///J_{ij} = (f_i(x + \delta_j) - f_i(x)) / \delta_j</span>
    <span class="doccomment">///```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// where \delta_j is a step of size \sqrt\epsilon |x_j| with \epsilon being the machine</span>
    <span class="doccomment">/// precision (\epsilon \approx 2.22 \times 10^{-16}). The order of convergence of Newton’s</span>
    <span class="doccomment">/// algorithm is quadratic, but the finite differences require n^2 function evaluations on</span>
    <span class="doccomment">/// each iteration. The algorithm may become unstable if the finite differences are not a</span>
    <span class="doccomment">/// good approximation to the true derivatives.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_dnewton&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">dnewton</span>() -&gt; <span class="ident">MultiRootFSolverType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_multiroot_fsolver_dnewton</span>)
    }

    <span class="doccomment">/// The Broyden algorithm is a version of the discrete Newton algorithm which attempts to</span>
    <span class="doccomment">/// avoids the expensive update of the Jacobian matrix on each iteration. The changes to</span>
    <span class="doccomment">/// the Jacobian are also approximated, using a rank-1 update,</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///```text</span>
    <span class="doccomment">///J^{-1} \to J^{-1} - (J^{-1} df - dx) dx^T J^{-1} / dx^T J^{-1} df</span>
    <span class="doccomment">///```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// where the vectors dx and df are the changes in x and f. On the first iteration the inverse</span>
    <span class="doccomment">/// Jacobian is estimated using finite differences, as in the discrete Newton algorithm.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This approximation gives a fast update but is unreliable if the changes are not small, and</span>
    <span class="doccomment">/// the estimate of the inverse Jacobian becomes worse as time passes. The algorithm has a</span>
    <span class="doccomment">/// tendency to become unstable unless it starts close to the root. The Jacobian is refreshed</span>
    <span class="doccomment">/// if this instability is detected (consult the source for details).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This algorithm is included only for demonstration purposes, and is not recommended for</span>
    <span class="doccomment">/// serious use.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_broyden&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">broyden</span>() -&gt; <span class="ident">MultiRootFSolverType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_multiroot_fsolver_broyden</span>)
    }
}

<span class="macro">ffi_wrapper!</span>(
    <span class="ident">MultiRootFSolver</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>,
    <span class="kw-2">*mut</span> <span class="ident">sys::gsl_multiroot_fsolver</span>,
    <span class="ident">gsl_multiroot_fsolver_free</span>
    ;<span class="ident">inner_call</span>: <span class="ident">sys::gsl_multiroot_function_struct</span> =&gt; <span class="ident">sys::gsl_multiroot_function_struct</span>{ <span class="ident">f</span>: <span class="prelude-val">None</span>, <span class="ident">n</span>: <span class="number">0</span>, <span class="ident">params</span>: <span class="ident">std::ptr::null_mut</span>() };
    ;<span class="ident">inner_closure</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Fn</span>(<span class="kw-2">&amp;</span><span class="ident">::VectorF64</span>, <span class="kw-2">&amp;mut</span> <span class="ident">::VectorF64</span>) -&gt; <span class="ident">::Value</span> <span class="op">+</span> <span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span> =&gt; <span class="prelude-val">None</span>;,
    <span class="string">&quot;This is a workspace for multidimensional root-finding without derivatives.&quot;</span>
);

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">MultiRootFSolver</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// This function returns a pointer to a newly allocated instance of a solver of type `T` with</span>
    <span class="doccomment">/// `n` unknowns.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If there is insufficient memory to create the solver then the function returns a null</span>
    <span class="doccomment">/// pointer and the error handler is invoked with an error code of `Value::NoMemory`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_alloc&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">t</span>: <span class="kw-2">&amp;</span><span class="ident">MultiRootFSolverType</span>, <span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">MultiRootFSolver</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">sys::gsl_multiroot_fsolver_alloc</span>(<span class="ident">t</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">n</span>) };

        <span class="kw">if</span> <span class="ident">ptr</span>.<span class="ident">is_null</span>() {
            <span class="prelude-val">None</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Some</span>(<span class="ident">MultiRootFSolver::wrap</span>(<span class="ident">ptr</span>))
        }
    }

    <span class="doccomment">/// This function initializes, or reinitializes, an existing solver `s` to use the multi</span>
    <span class="doccomment">/// function `f` with `n` unknowns.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_set&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set</span><span class="op">&lt;</span><span class="ident">F</span>: <span class="ident">Fn</span>(<span class="kw-2">&amp;</span><span class="ident">::VectorF64</span>, <span class="kw-2">&amp;mut</span> <span class="ident">::VectorF64</span>) -&gt; <span class="ident">::Value</span> <span class="op">+</span> <span class="lifetime">&#39;a</span><span class="op">&gt;</span>(
        <span class="kw-2">&amp;mut</span> <span class="self">self</span>,
        <span class="ident">f</span>: <span class="ident">F</span>,
        <span class="ident">n</span>: <span class="ident">usize</span>,
        <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">::VectorF64</span>,
    ) -&gt; <span class="ident">::Value</span> {
        <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">inner_f</span><span class="op">&lt;</span><span class="ident">A</span>: <span class="ident">Fn</span>(<span class="kw-2">&amp;</span><span class="ident">::VectorF64</span>, <span class="kw-2">&amp;mut</span> <span class="ident">::VectorF64</span>) -&gt; <span class="ident">::Value</span><span class="op">&gt;</span>(
            <span class="ident">x</span>: <span class="kw-2">*const</span> <span class="ident">sys::gsl_vector</span>,
            <span class="ident">params</span>: <span class="kw-2">*mut</span> <span class="ident">c_void</span>,
            <span class="ident">f</span>: <span class="kw-2">*mut</span> <span class="ident">sys::gsl_vector</span>,
        ) -&gt; <span class="ident">c_int</span> {
            <span class="kw">let</span> <span class="ident">g</span>: <span class="kw-2">&amp;</span><span class="ident">A</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span>(<span class="ident">params</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">A</span>);
            <span class="kw">let</span> <span class="ident">x_new</span> <span class="op">=</span> <span class="ident">::VectorF64::soft_wrap</span>(<span class="ident">x</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span>);
            <span class="ident">::Value::into</span>(<span class="ident">g</span>(<span class="kw-2">&amp;</span><span class="ident">x_new</span>, <span class="kw-2">&amp;mut</span> <span class="ident">::VectorF64::soft_wrap</span>(<span class="ident">f</span>)))
        }

        <span class="self">self</span>.<span class="ident">inner_call</span> <span class="op">=</span> <span class="ident">sys::gsl_multiroot_function_struct</span> {
            <span class="ident">f</span>: <span class="prelude-val">Some</span>(<span class="ident">inner_f</span>::<span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span>),
            <span class="ident">n</span>,
            <span class="ident">params</span>: <span class="kw-2">&amp;</span><span class="ident">f</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span>,
        };
        <span class="self">self</span>.<span class="ident">inner_closure</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Box::new</span>(<span class="ident">f</span>));

        <span class="ident">::Value::from</span>(<span class="kw">unsafe</span> {
            <span class="ident">sys::gsl_multiroot_fsolver_set</span>(
                <span class="self">self</span>.<span class="ident">unwrap_unique</span>(),
                <span class="kw-2">&amp;mut</span> <span class="self">self</span>.<span class="ident">inner_call</span>,
                <span class="ident">x</span>.<span class="ident">unwrap_shared</span>(),
            )
        })
    }

    <span class="doccomment">/// This function performs a single iteration of the minimizer s. If the iteration encounters an</span>
    <span class="doccomment">/// unexpected problem then an error code will be returned,</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ::Value::BadFunc</span>
    <span class="doccomment">/// the iteration encountered a singular point where the function evaluated to Inf or NaN.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ::Value::Failure</span>
    <span class="doccomment">/// the algorithm could not improve the current best approximation or bounding interval.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The minimizer maintains a current best estimate of the position of the minimum at all times,</span>
    <span class="doccomment">/// and the current interval bounding the minimum. This information can be accessed with the</span>
    <span class="doccomment">/// following auxiliary functions,</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_iterate&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">iterate</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="ident">::Value</span> {
        <span class="ident">::Value::from</span>(<span class="kw">unsafe</span> { <span class="ident">sys::gsl_multiroot_fsolver_iterate</span>(<span class="self">self</span>.<span class="ident">unwrap_unique</span>()) })
    }

    <span class="doccomment">/// This function returns the current estimate of the root for the solver `s`, given by `s-&gt;x`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_root&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">root</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">::VectorF64</span> {
        <span class="ident">::VectorF64::soft_wrap</span>(<span class="kw">unsafe</span> { <span class="ident">sys::gsl_multiroot_fsolver_root</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>()) })
    }

    <span class="doccomment">/// This function returns the last step `dx` taken by the solver `s`, given by `s-&gt;dx`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_dx&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">dx</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">::VectorF64</span> {
        <span class="ident">::VectorF64::soft_wrap</span>(<span class="kw">unsafe</span> { <span class="ident">sys::gsl_multiroot_fsolver_dx</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>()) })
    }

    <span class="doccomment">/// This function returns the function value `f(x)` at the current estimate of the root for</span>
    <span class="doccomment">/// the solver `s`, given by `s-&gt;f`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_multiroot_fsolver_f&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">f</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">::VectorF64</span> {
        <span class="ident">::VectorF64::soft_wrap</span>(<span class="kw">unsafe</span> { <span class="ident">sys::gsl_multiroot_fsolver_f</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>()) })
    }
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">test</span>, <span class="ident">doctest</span>))]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
    <span class="doccomment">/// This doc block will be used to ensure that the closure can&#39;t be set everywhere!</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```compile_fail</span>
    <span class="doccomment">/// use rgsl::*;</span>
    <span class="doccomment">/// use rgsl::types::multiroot::{MultiRootFSolver, MultiRootFSolverType};</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// fn set(root: &amp;mut MultiRootFSolver) {</span>
    <span class="doccomment">///     let dummy = &quot;lalal&quot;.to_owned();</span>
    <span class="doccomment">///     root.set(|x, y| {</span>
    <span class="doccomment">///         println!(&quot;==&gt; {:?}&quot;, dummy);</span>
    <span class="doccomment">///         y.set(0, 1.0 - x.get(0));</span>
    <span class="doccomment">///         y.set(1, x.get(0) - x.get(1));</span>
    <span class="doccomment">///         rgsl::Value::Success}, 2, &amp;rgsl::VectorF64::from_slice(&amp;[-10.0, 1.0]).unwrap());</span>
    <span class="doccomment">/// }</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let mut root = MultiRootFSolver::new(&amp;MultiRootFSolverType::hybrid(), 2).unwrap();</span>
    <span class="doccomment">/// set(&amp;mut root);</span>
    <span class="doccomment">/// let status = root.iterate();</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Same but a working version:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// use rgsl::types::multiroot::{MultiRootFSolver, MultiRootFSolverType};</span>
    <span class="doccomment">/// use rgsl::*;</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// fn set(root: &amp;mut MultiRootFSolver) {</span>
    <span class="doccomment">///     root.set(|x, y| {</span>
    <span class="doccomment">///         y.set(0, 1.0 - x.get(0));</span>
    <span class="doccomment">///         y.set(1, x.get(0) - x.get(1));</span>
    <span class="doccomment">///         rgsl::Value::Success}, 2, &amp;rgsl::VectorF64::from_slice(&amp;[-10.0, 1.0]).unwrap());</span>
    <span class="doccomment">/// }</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let mut root = MultiRootFSolver::new(&amp;MultiRootFSolverType::hybrid(), 2).unwrap();</span>
    <span class="doccomment">/// set(&amp;mut root);</span>
    <span class="doccomment">/// let status = root.iterate();</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">///</span>
    <span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;
    <span class="kw">use</span> <span class="ident">multiroot::test_residual</span>;
    <span class="kw">use</span> <span class="ident">VectorF64</span>;

    <span class="doccomment">/// checking a test function</span>
    <span class="doccomment">/// must return a success criteria (or failure)</span>
    <span class="kw">fn</span> <span class="ident">rosenbrock_f</span>(<span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">VectorF64</span>, <span class="ident">f</span>: <span class="kw-2">&amp;mut</span> <span class="ident">VectorF64</span>) -&gt; <span class="ident">::Value</span> {
        <span class="ident">f</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="number">1.0</span> <span class="op">-</span> <span class="ident">x</span>.<span class="ident">get</span>(<span class="number">0</span>));
        <span class="ident">f</span>.<span class="ident">set</span>(<span class="number">1</span>, <span class="ident">x</span>.<span class="ident">get</span>(<span class="number">0</span>) <span class="op">-</span> <span class="ident">x</span>.<span class="ident">get</span>(<span class="number">1</span>).<span class="ident">powf</span>(<span class="number">2.0</span>));
        <span class="ident">::Value::Success</span>
    }

    <span class="kw">fn</span> <span class="ident">print_state</span>(<span class="ident">solver</span>: <span class="kw-2">&amp;mut</span> <span class="ident">MultiRootFSolver</span>, <span class="ident">iteration</span>: <span class="ident">usize</span>) {
        <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">solver</span>.<span class="ident">f</span>();
        <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">solver</span>.<span class="ident">root</span>();
        <span class="macro">println!</span>(
            <span class="string">&quot;iter: {}, f = [{:+.2e}, {:+.2e}], x = [{:+.5}, {:+.5}]&quot;</span>,
            <span class="ident">iteration</span>,
            <span class="ident">f</span>.<span class="ident">get</span>(<span class="number">0</span>),
            <span class="ident">f</span>.<span class="ident">get</span>(<span class="number">1</span>),
            <span class="ident">x</span>.<span class="ident">get</span>(<span class="number">0</span>),
            <span class="ident">x</span>.<span class="ident">get</span>(<span class="number">1</span>)
        )
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">test_multiroot_fsolver</span>() {
        <span class="comment">// setup workspace</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">multi_root</span> <span class="op">=</span> <span class="ident">MultiRootFSolver::new</span>(<span class="kw-2">&amp;</span><span class="ident">MultiRootFSolverType::hybrid</span>(), <span class="number">2</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">array_size</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">2</span>;
        <span class="kw">let</span> <span class="ident">guess_value</span> <span class="op">=</span> <span class="ident">VectorF64::from_slice</span>(<span class="kw-2">&amp;</span>[<span class="op">-</span><span class="number">10.0</span>, <span class="op">-</span><span class="number">5.0</span>]).<span class="ident">unwrap</span>();
        <span class="ident">multi_root</span>.<span class="ident">set</span>(<span class="kw-2">&amp;</span><span class="ident">rosenbrock_f</span>, <span class="ident">array_size</span>, <span class="kw-2">&amp;</span><span class="ident">guess_value</span>);

        <span class="comment">// iteration counters</span>
        <span class="kw">let</span> <span class="ident">max_iter</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">100</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="number">0</span>;

        <span class="comment">// convergence checks</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">status</span> <span class="op">=</span> <span class="ident">::Value::Continue</span>;
        <span class="kw">let</span> <span class="ident">epsabs</span> <span class="op">=</span> <span class="number">1e-6</span>;

        <span class="ident">print_state</span>(<span class="kw-2">&amp;mut</span> <span class="ident">multi_root</span>, <span class="number">0</span>);

        <span class="kw">while</span> <span class="macro">matches!</span>(<span class="ident">status</span>, <span class="ident">::Value::Continue</span>) <span class="op">&amp;&amp;</span> <span class="ident">iter</span> <span class="op">&lt;</span> <span class="ident">max_iter</span> {
            <span class="comment">// iterate solver</span>
            <span class="ident">status</span> <span class="op">=</span> <span class="ident">multi_root</span>.<span class="ident">iterate</span>();

            <span class="comment">// check iteration for failure (e.g. BadEquation (f set to inf or NaN) or</span>
            <span class="comment">// ENoProg (not or bad progress).</span>
            <span class="kw">if</span> <span class="op">!</span><span class="macro">matches!</span>(<span class="ident">status</span>, <span class="ident">::Value::Success</span>) {
                <span class="kw">break</span>;
            }

            <span class="comment">// print current iteration</span>
            <span class="ident">print_state</span>(<span class="kw-2">&amp;mut</span> <span class="ident">multi_root</span>, <span class="ident">iter</span>);

            <span class="comment">// test for convergence</span>
            <span class="kw">let</span> <span class="ident">f_value</span> <span class="op">=</span> <span class="ident">multi_root</span>.<span class="ident">f</span>();
            <span class="ident">status</span> <span class="op">=</span> <span class="ident">test_residual</span>(<span class="kw-2">&amp;</span><span class="ident">f_value</span>, <span class="ident">epsabs</span>);

            <span class="comment">// check if iteration succeeded</span>
            <span class="kw">if</span> <span class="macro">matches!</span>(<span class="ident">status</span>, <span class="ident">::Value::Success</span>) {
                <span class="macro">println!</span>(<span class="string">&quot;Converged&quot;</span>);
            }

            <span class="ident">iter</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        }
        <span class="macro">assert!</span>(<span class="macro">matches!</span>(<span class="ident">status</span>, <span class="ident">::Value::Success</span>))
    }
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="rgsl" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>