<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-6.0.0/src/types/interpolation.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>interpolation.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../rgsl/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../rgsl/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../rgsl/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
</pre><pre class="rust"><code><span class="comment">//</span>
<span class="comment">// A rust binding for the GSL library by Guillaume Gomez (guillaume1.gomez@gmail.com)</span>
<span class="comment">//</span>

<span class="doccomment">/*!
# Interpolation

This chapter describes functions for performing interpolation. The library provides a variety of interpolation methods, including Cubic splines
and Akima splines. The interpolation types are interchangeable, allowing different methods to be used without recompiling. Interpolations can
be defined for both normal and periodic boundary conditions. Additional functions are available for computing derivatives and integrals of
interpolating functions.

These interpolation methods produce curves that pass through each datapoint. To interpolate noisy data with a smoothing curve see Basis Splines.

## Introduction

Given a set of data points (x_1, y_1) \dots (x_n, y_n) the routines described in this section compute a continuous interpolating function
y(x) such that y(x_i) = y_i. The interpolation is piecewise smooth, and its behavior at the end-points is determined by the type of
interpolation used.

## Index Look-up and Acceleration

The state of searches can be stored in a gsl_interp_accel object, which is a kind of iterator for interpolation lookups. It caches the previous
value of an index lookup. When the subsequent interpolation point falls in the same interval its index value can be returned immediately.

## Higher-level Interface

The functions described in the previous sections required the user to supply pointers to the x and y arrays on each call. The following
functions are equivalent to the corresponding gsl_interp functions but maintain a copy of this data in the gsl_spline object. This removes
the need to pass both xa and ya as arguments on each evaluation.

## References and Further Reading

Descriptions of the interpolation algorithms and further references can be found in the following books:

C.W. Ueberhuber, Numerical Computation (Volume 1), Chapter 9 “Interpolation”, Springer (1997), ISBN 3-540-62058-3.
D.M. Young, R.T. Gregory A Survey of Numerical Mathematics (Volume 1), Chapter 6.8, Dover (1988), ISBN 0-486-65691-8.
!*/</span>

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::Value</span>;
<span class="kw">use</span> <span class="ident">ffi::FFI</span>;

<span class="doccomment">/// Evaluation accelerator.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">InterpAccel</span>(<span class="kw">pub</span> <span class="ident">sys::gsl_interp_accel</span>);

<span class="kw">impl</span> <span class="ident">InterpAccel</span> {
    <span class="doccomment">/// This function returns a pointer to an accelerator object, which is a kind of iterator for</span>
    <span class="doccomment">/// interpolation lookups. It tracks the state of lookups, thus allowing for application of</span>
    <span class="doccomment">/// various acceleration strategies.</span>
    <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::new_without_default</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>() -&gt; <span class="ident">InterpAccel</span> {
        <span class="ident">InterpAccel</span>(<span class="ident">sys::gsl_interp_accel</span> {
            <span class="ident">cache</span>: <span class="number">0</span>,
            <span class="ident">miss_count</span>: <span class="number">0</span>,
            <span class="ident">hit_count</span>: <span class="number">0</span>,
        })
    }

    <span class="doccomment">/// This function reinitializes the accelerator object acc. It should be used when the cached</span>
    <span class="doccomment">/// information is no longer applicable-for example, when switching to a new dataset.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">reset</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">cache</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">miss_count</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">hit_count</span> <span class="op">=</span> <span class="number">0</span>;
    }

    <span class="doccomment">/// This function performs a lookup action on the data array x_array of size size, using the</span>
    <span class="doccomment">/// given accelerator a. This is how lookups are performed during evaluation of an</span>
    <span class="doccomment">/// interpolation. The function returns an index i such that `x_array[i] &lt;= x &lt; x_array[i+1]`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_accel_find&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">find</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">x_array</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">x</span>: <span class="ident">f64</span>) -&gt; <span class="ident">usize</span> {
        <span class="kw">unsafe</span> { <span class="ident">sys::gsl_interp_accel_find</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>.<span class="number">0</span>, <span class="ident">x_array</span>.<span class="ident">as_ptr</span>(), <span class="ident">x_array</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="kw">_</span>, <span class="ident">x</span>) }
    }
}

<span class="macro">ffi_wrapper!</span>(<span class="ident">Interp</span>, <span class="kw-2">*mut</span> <span class="ident">sys::gsl_interp</span>, <span class="ident">gsl_interp_free</span>);

<span class="kw">impl</span> <span class="ident">Interp</span> {
    <span class="doccomment">/// This function returns a pointer to a newly allocated interpolation object of type T for</span>
    <span class="doccomment">/// size data-points.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// use rgsl::{Interp, InterpType};</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let interp_type = InterpType::linear();</span>
    <span class="doccomment">/// let interp = Interp::new(interp_type, 2).expect(&quot;Failed to initialize `Interp`...&quot;);</span>
    <span class="doccomment">/// ```</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_alloc&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">t</span>: <span class="ident">InterpType</span>, <span class="ident">size</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Interp</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">sys::gsl_interp_alloc</span>(<span class="ident">t</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">size</span>) };

        <span class="kw">if</span> <span class="ident">tmp</span>.<span class="ident">is_null</span>() {
            <span class="prelude-val">None</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Some</span>(<span class="ident"><span class="self">Self</span>::wrap</span>(<span class="ident">tmp</span>))
        }
    }

    <span class="doccomment">/// This function initializes the interpolation object interp for the data (xa,ya) where xa and</span>
    <span class="doccomment">/// ya are arrays of size size. The interpolation object (gsl_interp) does not save the data</span>
    <span class="doccomment">/// arrays xa and ya and only stores the static state computed from the data. The xa data array</span>
    <span class="doccomment">/// is always assumed to be strictly ordered, with increasing x values; the behavior for other</span>
    <span class="doccomment">/// arrangements is not defined.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Asserts that `ya.len() &gt;= xa.len()`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_init&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">init</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">xa</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">ya</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>]) -&gt; <span class="ident">Value</span> {
        <span class="macro">assert!</span>(<span class="ident">ya</span>.<span class="ident">len</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="ident">xa</span>.<span class="ident">len</span>());
        <span class="ident">Value::from</span>(<span class="kw">unsafe</span> {
            <span class="ident">sys::gsl_interp_init</span>(
                <span class="self">self</span>.<span class="ident">unwrap_unique</span>(),
                <span class="ident">xa</span>.<span class="ident">as_ptr</span>(),
                <span class="ident">ya</span>.<span class="ident">as_ptr</span>(),
                <span class="ident">xa</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="kw">_</span>,
            )
        })
    }

    <span class="doccomment">/// This function returns the name of the interpolation type used by interp. For example,</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// use rgsl::{Interp, InterpType};</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let interp_type = InterpType::linear();</span>
    <span class="doccomment">/// let interp = Interp::new(interp_type, 2).expect(&quot;Failed to initialize `Interp`...&quot;);</span>
    <span class="doccomment">/// println!(&quot;interp uses &#39;{}&#39; interpolation.&quot;, interp.name());</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// would print something like :</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```Shell</span>
    <span class="doccomment">/// interp uses &#39;cspline&#39; interpolation.</span>
    <span class="doccomment">/// ```</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_name&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span> {
        <span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">sys::gsl_interp_name</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>()) };

        <span class="kw">if</span> <span class="ident">tmp</span>.<span class="ident">is_null</span>() {
            <span class="ident">String::new</span>()
        } <span class="kw">else</span> {
            <span class="kw">unsafe</span> {
                <span class="ident">String::from_utf8_lossy</span>(<span class="ident">::std::ffi::CStr::from_ptr</span>(<span class="ident">tmp</span>).<span class="ident">to_bytes</span>()).<span class="ident">to_string</span>()
            }
        }
    }

    <span class="doccomment">/// This function returns the minimum number of points required by the interpolation object</span>
    <span class="doccomment">/// interp or interpolation type T. For example, Akima spline interpolation requires a minimum</span>
    <span class="doccomment">/// of 5 points.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_min_size&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">min_size</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u32</span> {
        <span class="kw">unsafe</span> { <span class="ident">sys::gsl_interp_min_size</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>()) }
    }
}

<span class="macro">ffi_wrapper!</span>(<span class="ident">InterpType</span>, <span class="kw-2">*const</span> <span class="ident">sys::gsl_interp_type</span>);

<span class="kw">impl</span> <span class="ident">InterpType</span> {
    <span class="doccomment">/// This function returns the minimum number of points required by the interpolation object</span>
    <span class="doccomment">/// interp or interpolation type T. For example, Akima spline interpolation requires a minimum</span>
    <span class="doccomment">/// of 5 points.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_type_min_size&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">min_size</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u32</span> {
        <span class="kw">unsafe</span> { <span class="ident">sys::gsl_interp_type_min_size</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>()) }
    }

    <span class="doccomment">/// Linear interpolation. This interpolation method does not require any additional memory.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_linear&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">linear</span>() -&gt; <span class="ident">InterpType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_interp_linear</span>)
    }

    <span class="doccomment">/// Polynomial interpolation. This method should only be used for interpolating small numbers</span>
    <span class="doccomment">/// of points because polynomial interpolation introduces large oscillations, even for</span>
    <span class="doccomment">/// well-behaved datasets. The number of terms in the interpolating polynomial is equal to the</span>
    <span class="doccomment">/// number of points.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_polynomial&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">polynomial</span>() -&gt; <span class="ident">InterpType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_interp_polynomial</span>)
    }

    <span class="doccomment">/// Cubic spline with natural boundary conditions. The resulting curve is piecewise cubic on</span>
    <span class="doccomment">/// each interval, with matching first and second derivatives at the supplied data-points. The</span>
    <span class="doccomment">/// second derivative is chosen to be zero at the first point and last point.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_cspline&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">cspline</span>() -&gt; <span class="ident">InterpType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_interp_cspline</span>)
    }

    <span class="doccomment">/// Cubic spline with periodic boundary conditions. The resulting curve is piecewise cubic on</span>
    <span class="doccomment">/// each interval, with matching first and second derivatives at the supplied data-points. The</span>
    <span class="doccomment">/// derivatives at the first and last points are also matched. Note that the last point in the</span>
    <span class="doccomment">/// data must have the same y-value as the first point, otherwise the resulting periodic</span>
    <span class="doccomment">/// interpolation will have a discontinuity at the boundary.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_cspline_periodic&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">cspline_periodic</span>() -&gt; <span class="ident">InterpType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_interp_cspline_periodic</span>)
    }

    <span class="doccomment">/// Non-rounded Akima spline with natural boundary conditions. This method uses the non-rounded</span>
    <span class="doccomment">/// corner algorithm of Wodicka.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_akima&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">akima</span>() -&gt; <span class="ident">InterpType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_interp_akima</span>)
    }

    <span class="doccomment">/// Non-rounded Akima spline with periodic boundary conditions. This method uses the non-rounded</span>
    <span class="doccomment">/// corner algorithm of Wodicka.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_interp_akima_periodic&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">akima_periodic</span>() -&gt; <span class="ident">InterpType</span> {
        <span class="macro">ffi_wrap!</span>(<span class="ident">gsl_interp_akima_periodic</span>)
    }
}

<span class="macro">ffi_wrapper!</span>(
    <span class="ident">Spline</span>,
    <span class="kw-2">*mut</span> <span class="ident">sys::gsl_spline</span>,
    <span class="ident">gsl_spline_free</span>,
    <span class="string">&quot;General interpolation object.&quot;</span>
);

<span class="kw">impl</span> <span class="ident">Spline</span> {
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_alloc&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">t</span>: <span class="ident">InterpType</span>, <span class="ident">size</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Spline</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_alloc</span>(<span class="ident">t</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">size</span>) };

        <span class="kw">if</span> <span class="ident">tmp</span>.<span class="ident">is_null</span>() {
            <span class="prelude-val">None</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Some</span>(<span class="ident"><span class="self">Self</span>::wrap</span>(<span class="ident">tmp</span>))
        }
    }

    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_init&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">init</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">xa</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>], <span class="ident">ya</span>: <span class="kw-2">&amp;</span>[<span class="ident">f64</span>]) -&gt; <span class="ident">Value</span> {
        <span class="ident">Value::from</span>(<span class="kw">unsafe</span> {
            <span class="ident">sys::gsl_spline_init</span>(
                <span class="self">self</span>.<span class="ident">unwrap_unique</span>(),
                <span class="ident">xa</span>.<span class="ident">as_ptr</span>(),
                <span class="ident">ya</span>.<span class="ident">as_ptr</span>(),
                <span class="ident">xa</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="kw">_</span>,
            )
        })
    }

    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_name&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span> {
        <span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_name</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>()) };

        <span class="kw">if</span> <span class="ident">tmp</span>.<span class="ident">is_null</span>() {
            <span class="ident">String::new</span>()
        } <span class="kw">else</span> {
            <span class="kw">unsafe</span> {
                <span class="ident">String::from_utf8_lossy</span>(<span class="ident">::std::ffi::CStr::from_ptr</span>(<span class="ident">tmp</span>).<span class="ident">to_bytes</span>()).<span class="ident">to_string</span>()
            }
        }
    }

    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_min_size&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">min_size</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u32</span> {
        <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_min_size</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>()) }
    }

    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_eval&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">eval</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="ident">f64</span>, <span class="ident">acc</span>: <span class="kw-2">&amp;mut</span> <span class="ident">InterpAccel</span>) -&gt; <span class="ident">f64</span> {
        <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_eval</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">x</span>, <span class="kw-2">&amp;mut</span> <span class="ident">acc</span>.<span class="number">0</span>) }
    }

    <span class="doccomment">/// Returns `(Value, y)`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_eval_e&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">eval_e</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="ident">f64</span>, <span class="ident">acc</span>: <span class="kw-2">&amp;mut</span> <span class="ident">InterpAccel</span>) -&gt; (<span class="ident">Value</span>, <span class="ident">f64</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">y</span> <span class="op">=</span> <span class="number">0.</span>;
        <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_eval_e</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">x</span>, <span class="kw-2">&amp;mut</span> <span class="ident">acc</span>.<span class="number">0</span>, <span class="kw-2">&amp;mut</span> <span class="ident">y</span>) };
        (<span class="ident">Value::from</span>(<span class="ident">ret</span>), <span class="ident">y</span>)
    }

    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_eval_deriv&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">eval_deriv</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="ident">f64</span>, <span class="ident">acc</span>: <span class="kw-2">&amp;mut</span> <span class="ident">InterpAccel</span>) -&gt; <span class="ident">f64</span> {
        <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_eval_deriv</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">x</span>, <span class="kw-2">&amp;mut</span> <span class="ident">acc</span>.<span class="number">0</span>) }
    }

    <span class="doccomment">/// Returns `(Value, d)`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_eval_deriv_e&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">eval_deriv_e</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="ident">f64</span>, <span class="ident">acc</span>: <span class="kw-2">&amp;mut</span> <span class="ident">InterpAccel</span>) -&gt; (<span class="ident">Value</span>, <span class="ident">f64</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">d</span> <span class="op">=</span> <span class="number">0.</span>;
        <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span>
            <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_eval_deriv_e</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">x</span>, <span class="kw-2">&amp;mut</span> <span class="ident">acc</span>.<span class="number">0</span>, <span class="kw-2">&amp;mut</span> <span class="ident">d</span>) };
        (<span class="ident">Value::from</span>(<span class="ident">ret</span>), <span class="ident">d</span>)
    }

    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_eval_deriv2&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">eval_deriv2</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="ident">f64</span>, <span class="ident">acc</span>: <span class="kw-2">&amp;mut</span> <span class="ident">InterpAccel</span>) -&gt; <span class="ident">f64</span> {
        <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_eval_deriv2</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">x</span>, <span class="kw-2">&amp;mut</span> <span class="ident">acc</span>.<span class="number">0</span>) }
    }

    <span class="doccomment">/// Returns `(Value, d2)`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_eval_deriv2_e&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">eval_deriv2_e</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="ident">f64</span>, <span class="ident">acc</span>: <span class="kw-2">&amp;mut</span> <span class="ident">InterpAccel</span>) -&gt; (<span class="ident">Value</span>, <span class="ident">f64</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">d2</span> <span class="op">=</span> <span class="number">0.</span>;
        <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span>
            <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_eval_deriv2_e</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">x</span>, <span class="kw-2">&amp;mut</span> <span class="ident">acc</span>.<span class="number">0</span>, <span class="kw-2">&amp;mut</span> <span class="ident">d2</span>) };
        (<span class="ident">Value::from</span>(<span class="ident">ret</span>), <span class="ident">d2</span>)
    }

    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_eval_integ&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">eval_integ</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">a</span>: <span class="ident">f64</span>, <span class="ident">b</span>: <span class="ident">f64</span>, <span class="ident">acc</span>: <span class="kw-2">&amp;mut</span> <span class="ident">InterpAccel</span>) -&gt; <span class="ident">f64</span> {
        <span class="kw">unsafe</span> { <span class="ident">sys::gsl_spline_eval_integ</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">a</span>, <span class="ident">b</span>, <span class="kw-2">&amp;mut</span> <span class="ident">acc</span>.<span class="number">0</span>) }
    }

    <span class="doccomment">/// Returns `(Value, d2)`.</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;gsl_spline_eval_integ_e&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">eval_integ_e</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">a</span>: <span class="ident">f64</span>, <span class="ident">b</span>: <span class="ident">f64</span>, <span class="ident">acc</span>: <span class="kw-2">&amp;mut</span> <span class="ident">InterpAccel</span>) -&gt; (<span class="ident">Value</span>, <span class="ident">f64</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">0.</span>;
        <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="kw">unsafe</span> {
            <span class="ident">sys::gsl_spline_eval_integ_e</span>(<span class="self">self</span>.<span class="ident">unwrap_shared</span>(), <span class="ident">a</span>, <span class="ident">b</span>, <span class="kw-2">&amp;mut</span> <span class="ident">acc</span>.<span class="number">0</span>, <span class="kw-2">&amp;mut</span> <span class="ident">result</span>)
        };
        (<span class="ident">Value::from</span>(<span class="ident">ret</span>), <span class="ident">result</span>)
    }
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="rgsl" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>